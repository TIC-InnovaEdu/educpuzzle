5",    # EURO SIGN
);
our %GSM2UNI = reverse %UNI2GSM;
our $ESC    = "\x1b";
our $ATMARK = "\x40";
our $FBCHAR = "\x3F";
our $NBSP   = "\x{00A0}";

#define ERR_DECODE_NOMAP "%s \"\\x%02" UVXf "\" does not map to Unicode"

sub decode ($$;$) {
    my ( $obj, $bytes, $chk ) = @_;
    return undef unless defined $bytes;
    my $str = substr($bytes, 0, 0); # to propagate taintedness;
    while ( length $bytes ) {
        my $c = substr( $bytes, 0, 1, '' );
        my $u;
        if ( $c eq "\x00" ) {
            my $c2 = substr( $bytes, 0, 1, '' );
            $u =
                !length $c2 ? $ATMARK
              : $c2 eq "\x00" ? "\x{0000}"
              : exists $GSM2UNI{$c2} ? $ATMARK . $GSM2UNI{$c2}
              : $chk
              ? croak sprintf( "\\x%02X\\x%02X does not map to Unicode",
			       ord($c), ord($c2) )
              : $ATMARK . $FBCHAR;

        }
        elsif ( $c eq $ESC ) {
            my $c2 = substr( $bytes, 0, 1, '' );
            $u =
                exists $GSM2UNI{ $c . $c2 } ? $GSM2UNI{ $c . $c2 }
              : exists $GSM2UNI{$c2}        ? 